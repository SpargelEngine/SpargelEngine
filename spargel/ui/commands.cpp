#include "spargel/ui/commands.h"

#include "spargel/ui/context.h"

namespace spargel::ui {
namespace {

CommandList& cmdlist() {
  auto& ctx = Context::get();
  return ctx.command_list();
}

}  // namespace

void begin_frame() { cmdlist().clear(); }
void fill_triangle(math::Vec2f p1, math::Vec2f p2, math::Vec2f p3, uint32_t c) {
  cmdlist().fill_tri(p1, p2, p3, c);
}
void fill_rect(math::Vec2f orig, math::Vec2f size, uint32_t c) {
  math::Vec2f p1 = orig;
  math::Vec2f p2 = {orig.x, orig.y + size.y};
  math::Vec2f p3 = {orig.x + size.x, orig.y + size.y};
  math::Vec2f p4 = {orig.x + size.x, orig.y};
  cmdlist().fill_tri(p1, p2, p3, c);
  cmdlist().fill_tri(p1, p3, p4, c);
}
void stroke_line(math::Vec2f p1, math::Vec2f p2, float thickness, uint32_t c) {
  cmdlist().stroke_line(p1, p2, thickness, c);
}

namespace detail {
bool in_rect(math::Vec2f p, math::Vec2f orig, math::Vec2f size) {
  return (p.x >= orig.x && p.y >= orig.y) &&
         (p.x <= (orig.x + size.x) && p.y <= (orig.y + size.y));
}
// generated by AI, not checked
uint32_t lighten_color(uint32_t color, float factor) {
  // Extract RGB components
  uint8_t r = (color >> 16) & 0xFF;
  uint8_t g = (color >> 8) & 0xFF;
  uint8_t b = color & 0xFF;
  uint8_t a = (color >> 24) & 0xFF;  // Preserve alpha

  // Lighten each component
  r = (uint8_t)(r + (255 - r) * factor);
  g = (uint8_t)(g + (255 - g) * factor);
  b = (uint8_t)(b + (255 - b) * factor);

  // Recombine
  return uint32_t((a << 24) | (r << 16) | (g << 8) | b);
}
}  // namespace detail

bool button(math::Vec2f orig, math::Vec2f size, uint32_t c) {
  auto& ctx = Context::get();
  auto const& state = ctx.input_state();
  uint32_t real_color = c;
  bool clicked = false;
  if (detail::in_rect(state.mouse_position, orig, size)) {
    if (state.mouse_released) {
      clicked = true;
    }
    if (state.mouse_down) {
      // the button is clicked
      real_color = detail::lighten_color(c, 0.8f);
    } else {
      // the button is hovered
      real_color = detail::lighten_color(c, 0.2f);
    }
  }
  fill_rect(orig, size, real_color);
  return clicked;
}

bool label_button(char const* text, math::Vec2f orig, math::Vec2f size,
                  uint32_t c) {
  auto clicked = button(orig, size, c);
  auto [width, ascent, descent] = cmdlist().measure_text(text);
  label(text,
        {
            orig.x + size.x / 2.0f - width / 2.0f,
            orig.y + size.y / 2.0f + ascent / 2.0f + descent / 2.0f,
        },
        0xFFFFFFFF);
  return clicked;
}

void slide(float* value, char const* text, math::Vec2f orig, math::Vec2f size,
           uint32_t c) {
  auto& ctx = Context::get();
  auto const& state = ctx.input_state();
  if (detail::in_rect(state.mouse_position, orig, size)) {
    if (state.mouse_down) {
      *value = (state.mouse_position.x - orig.x) / size.x;
      c = detail::lighten_color(c, 0.1f);
    } else {
      c = detail::lighten_color(c, 0.05f);
    }
  }
  fill_rect(orig, {size.x * (*value), size.y}, c);
  fill_rect({orig.x + size.x * (*value), orig.y},
            {size.x - size.x * (*value), size.y},
            detail::lighten_color(c, 0.1f));
  auto [width, ascent, descent] = cmdlist().measure_text(text);
  label(text,
        {
            orig.x + size.x / 2.0f - width / 2.0f,
            orig.y + size.y / 2.0f + ascent / 2.0f + descent / 2.0f,
        },
        0xFFFFFFFF);
}

void label(char const* text, math::Vec2f orig, uint32_t c) {
  cmdlist().fill_text(text, orig, c);
}

}  // namespace spargel::ui
