#! /usr/bin/env python3

import argparse
import hashlib
import json
import pathlib
import shutil
import sys

def report_error(msg):
    print(f"error: {msg}")

def report_info(msg):
    print(f"info: {msg}")

def load_config(args):
    config_path = args.project_dir / "spargel_project.json"
    if not config_path.exists():
        report_error("project does not exist")
        return 1
    with open(config_path) as f:
        config = json.load(f)
    return config

def cmd_check(args):
    config = load_config(args)

    report_info(f"checking project {config['name']}")

    #################
    ## Check assets.
    #################

    for asset in config["assets"]:
        target = asset["target"]
        # `local_path` is relative to `project_dir`.
        local_path = asset["path"]
        path = args.project_dir / local_path
        if not path.exists():
            report_error(f"asset {target} --> {path} does not exist")
            continue
        with open(path, "rb") as f:
            digest = hashlib.file_digest(f, "sha1")
        report_info(f"asset {target} --> {path} : sha1 = {digest.hexdigest()}")

    return 0

def ensure_dir(path):
    path.mkdir(parents = True, exist_ok = True)

def ninja_escape(s):
    return s.replace("/", "_").replace("\\", "_").replace(" ", "_")

def cmd_build(args):
    config = load_config(args)

    report_info(f"building project {config['name']}")

    ##################################################
    # Step 1. Create build dirs.
    # 
    # Structure:
    #   spargel/
    #     x.py
    #     build/
    #       cmake/              ; CMake build dir
    #       hello_world/        ; project output dir
    #         .build/
    #           build.ninja
    #           cmake_flags.txt
    #         assets/           ; project asset dir
    #           shaders/
    #           images/
    #           meshes/
    #           audios/
    #         hello_world       ; executable

    root_dir = pathlib.Path(__file__).parent.resolve()
    x_path = pathlib.Path(__file__).resolve()
    config_path = (args.project_dir / "spargel_project.json").resolve()

    output_dir = root_dir / "build" / config["name"]
    build_dir = output_dir / ".build"
    asset_dir = output_dir / "resources"
    ensure_dir(build_dir)

    cmake_build_dir = root_dir / "build" / "cmake"
    cmake_ninja_path = cmake_build_dir / "build.ninja"

    cmake_flags_path = build_dir / "cmake_flags.txt"
    if not cmake_flags_path.exists():
        with open(cmake_flags_path, "w") as f:
            f.write("# put cmake flags here\n")

    with open(cmake_flags_path, "r") as f:
        cmake_flags = []
        for line in f:
            line = line.split('#')[0].strip()
            if line:
                cmake_flags.append(line)

    report_info(f"cmake flags: {cmake_flags}")

    cmake_envs_path = build_dir / "cmake_envs.txt"
    if not cmake_envs_path.exists():
        with open(cmake_envs_path, "w") as f:
            f.write("# put cmake environment vars here\n")

    with open(cmake_envs_path, "r") as f:
        cmake_envs = []
        for line in f:
            line = line.split('#')[0].strip()
            if line:
                cmake_envs.append(line)

    report_info(f"cmake envs: {cmake_envs}")

    api_dir = cmake_build_dir / ".cmake" / "api" / "v1"
    query_dir = api_dir / "query"
    ensure_dir(query_dir)
    (query_dir / "codemodel-v2").touch()

    with open(build_dir / "build.ninja", "w") as f:
        f.write("# generated by x.py\n")
        f.write(f"cmake_flags = {' '.join(cmake_flags)}\n")
        f.write(f"cmake_envs = {' '.join(cmake_envs)}\n")
        f.write("rule run_cmake\n")
        f.write(f"  command = cmake -E env $cmake_envs -- cmake -S {root_dir} -B {cmake_build_dir} -G Ninja $cmake_flags\n")
        f.write("rule run_x\n")
        f.write(f"  command = python3 {x_path} build {args.project_dir.resolve()}\n")
        f.write(f"build build.ninja: run_x | {x_path} {config_path} cmake_flags.txt cmake_envs.txt\n")
        f.write(f"build {cmake_ninja_path}: run_cmake | {x_path} cmake_flags.txt cmake_envs.txt\n")
        f.write(f"build cmake: phony {cmake_ninja_path}\n")

        for exe in config["executables"]:
            name = exe["name"]
            cmake_target = exe["cmake_target_name"]
            dest = (output_dir / name).resolve()
            f.write(f"rule cmake_build_{name}\n")
            f.write(f"  command = cmake --build {cmake_build_dir} --target {cmake_target}\n")
            f.write(f"build build_{name}: cmake_build_{name}\n")

            f.write(f"rule copy_{name}\n")
            f.write(f"  command = python3 {x_path} copy --cmake-target {cmake_target} --dest {dest}\n")
            f.write(f"build {name}: copy_{name} | build_{name}\n")
            f.write(f"default {name}\n")

        for asset in config["assets"]:
            target = asset["target"]
            path = args.project_dir / asset["path"]

            if target[0] == '/':
                name = target[1:]
                target_path = (output_dir / name).resolve()
                ename = ninja_escape(name)
                f.write(f"rule copy_asset_{ename}\n")
                f.write(f"  command = cmake -E copy {path.resolve()} {target_path}\n")
                f.write(f"build {target_path}: copy_asset_{ename} | {path.resolve()}\n")

    return 0

def load_cmake_reply():
    root_dir = pathlib.Path(__file__).parent.resolve()
    indices = sorted((root_dir / "build" / "cmake" / ".cmake" / "api" / "v1" / "reply").glob("index-*.json"))
    return json.loads(indices[-1].read_text())["reply"]

def cmd_copy(args):
    target_name = args.cmake_target

    reply = load_cmake_reply()

    root_dir = pathlib.Path(__file__).parent.resolve()
    reply_dir = root_dir / "build" / "cmake" / ".cmake" / "api" / "v1" / "reply"

    codemodel_file = reply_dir / reply["codemodel-v2"]["jsonFile"]
    with open(codemodel_file, "r") as f:
        codemodel = json.load(f)

    for target in codemodel["configurations"][0]["targets"]:
        if target_name == target["name"]:
            target_file = reply_dir / target["jsonFile"]

            with open(target_file, "r") as f:
                target_config = json.load(f)

            artifacts = target_config["artifacts"]

            if len(artifacts) != 1:
                report_error("expect one artifact")
                return 1

            path = root_dir / "build" / "cmake" / artifacts[0]["path"]

            shutil.copy(path, args.dest)

            break
    
    return 0

def main():
    parser = argparse.ArgumentParser(description = "Spargel Engine Build System")
    subparsers = parser.add_subparsers(dest = "subparser_name", required = True)
    parser_build = subparsers.add_parser("build")
    parser_build.add_argument("project_dir", type = pathlib.Path)
    parser_check = subparsers.add_parser("check")
    parser_check.add_argument("project_dir", type = pathlib.Path)
    parser_clean = subparsers.add_parser("clean")
    parser_copy = subparsers.add_parser("copy")
    parser_copy.add_argument("--cmake-target", required = True)
    parser_copy.add_argument("--dest", type = pathlib.Path, required = True)
    args = parser.parse_args()
    if args.subparser_name == 'check':
        return cmd_check(args)
    elif args.subparser_name == 'build':
        return cmd_build(args)
    elif args.subparser_name == "copy":
        return cmd_copy(args)
    return 0

if __name__ == '__main__':
    sys.exit(main())
